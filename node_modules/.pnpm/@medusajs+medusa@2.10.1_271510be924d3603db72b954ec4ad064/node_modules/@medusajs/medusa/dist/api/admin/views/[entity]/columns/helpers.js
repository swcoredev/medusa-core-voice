"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEntityColumns = exports.DEFAULT_COLUMN_ORDERS = exports.getTypeInfoFromGraphQLType = exports.shouldExcludeField = exports.isSingleRelationship = exports.isArrayField = exports.getUnderlyingType = exports.formatFieldName = exports.getColumnCategory = void 0;
const utils_1 = require("@medusajs/framework/utils");
const modules_sdk_1 = require("@medusajs/framework/modules-sdk");
// Determine column category based on field characteristics
const getColumnCategory = (fieldName, dataType, semanticType) => {
    // Check semantic type first
    if (semanticType === "timestamp")
        return "timestamp";
    if (semanticType === "status")
        return "status";
    // Check field name patterns
    if (fieldName.includes("_id") ||
        fieldName === "id" ||
        fieldName.includes("display_id") ||
        fieldName === "code") {
        return "identifier";
    }
    if (fieldName.includes("status") || fieldName === "state") {
        return "status";
    }
    if (fieldName.includes("_at") || fieldName.includes("date")) {
        return "timestamp";
    }
    if (fieldName.includes("total") ||
        fieldName.includes("amount") ||
        fieldName.includes("price") ||
        semanticType === "currency") {
        return "metric";
    }
    if (dataType === "object" || fieldName.includes("_display")) {
        return "relationship";
    }
    return "metadata";
};
exports.getColumnCategory = getColumnCategory;
// Helper function to format field name for display
const formatFieldName = (field) => {
    return field
        .split(/[._]/)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
};
exports.formatFieldName = formatFieldName;
// Helper function to get the underlying type from wrapped types (NonNull, List)
const getUnderlyingType = (type) => {
    if (type.ofType) {
        return (0, exports.getUnderlyingType)(type.ofType);
    }
    return type;
};
exports.getUnderlyingType = getUnderlyingType;
// Helper function to check if a field type is an array/list
const isArrayField = (type) => {
    if ((0, utils_1.isListType)(type)) {
        return true;
    }
    if ((0, utils_1.isNonNullType)(type)) {
        return (0, exports.isArrayField)(type.ofType);
    }
    return false;
};
exports.isArrayField = isArrayField;
// Helper function to check if a field is a single relationship (many-to-one, one-to-one)
const isSingleRelationship = (type) => {
    // If it's a list, it's a one-to-many or many-to-many relationship
    if ((0, exports.isArrayField)(type)) {
        return false;
    }
    // Get the underlying type (removing NonNull wrappers)
    const underlyingType = (0, exports.getUnderlyingType)(type);
    // Check if it's a GraphQL object type (relationship)
    return underlyingType instanceof utils_1.GraphQLObjectType;
};
exports.isSingleRelationship = isSingleRelationship;
// Helper function to check if a field should be excluded based on filtering rules
const shouldExcludeField = (fieldName, fieldFilters) => {
    // Check if field matches any exclude suffixes
    if (fieldFilters.excludeSuffixes?.some((suffix) => fieldName.endsWith(suffix))) {
        return true;
    }
    // Check if field matches any exclude prefixes
    if (fieldFilters.excludePrefixes?.some((prefix) => fieldName.startsWith(prefix))) {
        return true;
    }
    // Check if field is in the exclude fields list
    if (fieldFilters.excludeFields?.includes(fieldName)) {
        return true;
    }
    return false;
};
exports.shouldExcludeField = shouldExcludeField;
// Helper function to determine data type and semantic type from GraphQL type
const getTypeInfoFromGraphQLType = (type, fieldName) => {
    const underlyingType = type ? (0, exports.getUnderlyingType)(type) : null;
    // Check field name patterns first for more specific types
    if (fieldName.includes("_at") || fieldName.includes("date")) {
        return {
            data_type: "date",
            semantic_type: "timestamp",
            context: fieldName.includes("created")
                ? "creation"
                : fieldName.includes("updated")
                    ? "update"
                    : "generic",
        };
    }
    else if (fieldName.includes("total") ||
        fieldName.includes("amount") ||
        fieldName.includes("price")) {
        return {
            data_type: "currency",
            semantic_type: "currency",
            context: fieldName.includes("total") ? "total" : "amount",
        };
    }
    else if (fieldName.includes("count") || fieldName.includes("quantity")) {
        return {
            data_type: "number",
            semantic_type: "count",
            context: fieldName.includes("quantity") ? "quantity" : "count",
        };
    }
    else if (fieldName.includes("status")) {
        return {
            data_type: "enum",
            semantic_type: "status",
            context: fieldName.includes("payment")
                ? "payment"
                : fieldName.includes("fulfillment")
                    ? "fulfillment"
                    : "generic",
        };
    }
    else if (fieldName.includes("type") || fieldName.includes("is_")) {
        return {
            data_type: "enum",
            semantic_type: "enum",
            context: "generic",
        };
    }
    else if (fieldName === "metadata" || fieldName.includes("json")) {
        return {
            data_type: "object",
            semantic_type: "object",
            context: "metadata",
        };
    }
    else if (fieldName === "display_id") {
        return {
            data_type: "string",
            semantic_type: "identifier",
            context: "order",
        };
    }
    else if (fieldName === "email") {
        return {
            data_type: "string",
            semantic_type: "email",
            context: "contact",
        };
    }
    // Then check GraphQL type
    if (underlyingType && (0, utils_1.isScalarType)(underlyingType)) {
        switch (underlyingType.name) {
            case "Int":
            case "Float":
                return {
                    data_type: "number",
                    semantic_type: "number",
                    context: "generic",
                };
            case "Boolean":
                return {
                    data_type: "boolean",
                    semantic_type: "boolean",
                    context: "generic",
                };
            case "DateTime":
                return {
                    data_type: "date",
                    semantic_type: "timestamp",
                    context: "generic",
                };
            case "JSON":
                return {
                    data_type: "object",
                    semantic_type: "object",
                    context: "json",
                };
            default:
                return {
                    data_type: "string",
                    semantic_type: "string",
                    context: "generic",
                };
        }
    }
    else if (underlyingType && (0, utils_1.isEnumType)(underlyingType)) {
        return {
            data_type: "enum",
            semantic_type: "enum",
            context: "generic",
        };
    }
    else {
        return {
            data_type: "object",
            semantic_type: "object",
            context: "relationship",
        };
    }
};
exports.getTypeInfoFromGraphQLType = getTypeInfoFromGraphQLType;
exports.DEFAULT_COLUMN_ORDERS = {
    display_id: 100,
    created_at: 200,
    customer_display: 300,
    "sales_channel.name": 400,
    fulfillment_status: 500,
    payment_status: 600,
    total: 700,
    country: 800,
};
/**
 * Generates columns for a given entity by introspecting the GraphQL schema
 * @param entity - The entity name to generate columns for
 * @param entityMapping - The entity mapping configuration
 * @returns Array of columns or null if generation fails
 */
const generateEntityColumns = (entity, entityMapping) => {
    const joinerConfigs = modules_sdk_1.MedusaModule.getAllJoinerConfigs();
    const schemaFragments = [];
    let hasEntityType = false;
    for (const config of joinerConfigs) {
        if (config.schema) {
            schemaFragments.push(config.schema);
            if (config.schema.includes(`type ${entityMapping.graphqlType} {`)) {
                hasEntityType = true;
            }
        }
    }
    if (!hasEntityType || schemaFragments.length === 0) {
        return null;
    }
    const scalarDefinitions = `
    scalar DateTime
    scalar JSON
  `;
    const allSchemas = [scalarDefinitions, ...schemaFragments];
    const mergedSchemaAST = (0, utils_1.mergeTypeDefs)(allSchemas);
    const mergedSchemaString = (0, utils_1.print)(mergedSchemaAST);
    const { schema: cleanedSchemaString } = (0, utils_1.cleanGraphQLSchema)(mergedSchemaString);
    const schema = (0, utils_1.makeExecutableSchema)({
        typeDefs: cleanedSchemaString,
        resolvers: {}, // Empty resolvers since we only need the schema for introspection
    });
    const schemaTypeMap = schema.getTypeMap();
    const entityType = schemaTypeMap[entityMapping.graphqlType];
    const allDirectFields = (0, utils_1.graphqlSchemaToFields)(schemaTypeMap, entityMapping.graphqlType, []);
    // Filter out problematic fields
    const directFields = allDirectFields.filter((fieldName) => {
        const field = entityType?.getFields()[fieldName];
        if (!field)
            return true;
        const isArray = (0, exports.isArrayField)(field.type);
        if (isArray) {
            return false;
        }
        if ((0, exports.shouldExcludeField)(fieldName, entityMapping.fieldFilters)) {
            return false;
        }
        return true;
    });
    if (entity === "orders" && !directFields.includes("display_id")) {
        directFields.unshift("display_id");
    }
    const relationMap = (0, utils_1.extractRelationsFromGQL)(new Map(Object.entries(schemaTypeMap)));
    const allEntityRelations = relationMap.get(entityMapping.graphqlType);
    const filteredUtilityRelations = new Map();
    if (allEntityRelations && entityType) {
        const fields = entityType.getFields();
        for (const [fieldName, relatedTypeName] of allEntityRelations) {
            const field = fields[fieldName];
            if ((0, exports.shouldExcludeField)(fieldName, entityMapping.fieldFilters)) {
                continue;
            }
            if (field && (0, exports.isSingleRelationship)(field.type)) {
                filteredUtilityRelations.set(fieldName, relatedTypeName);
            }
        }
    }
    const manualRelations = new Map();
    if (entityType) {
        const fields = entityType.getFields();
        Object.entries(fields).forEach(([fieldName, field]) => {
            if ((0, exports.shouldExcludeField)(fieldName, entityMapping.fieldFilters)) {
                return;
            }
            if ((0, exports.isSingleRelationship)(field.type)) {
                const fieldType = (0, exports.getUnderlyingType)(field.type);
                manualRelations.set(fieldName, fieldType.name);
            }
        });
    }
    const finalRelations = filteredUtilityRelations.size > 0
        ? filteredUtilityRelations
        : manualRelations;
    if (directFields.length === 0) {
        return null;
    }
    const directColumns = directFields.map((fieldName) => {
        const displayName = (0, exports.formatFieldName)(fieldName);
        const type = schemaTypeMap[entityMapping.graphqlType];
        const fieldDef = type?.getFields()?.[fieldName];
        const typeInfo = fieldDef
            ? (0, exports.getTypeInfoFromGraphQLType)(fieldDef.type, fieldName)
            : (0, exports.getTypeInfoFromGraphQLType)(null, fieldName);
        const sortable = !fieldName.includes("metadata") && typeInfo.data_type !== "object";
        const isDefaultField = entityMapping.defaultVisibleFields.includes(fieldName);
        const defaultOrder = exports.DEFAULT_COLUMN_ORDERS[fieldName] || (isDefaultField ? 500 : 850);
        const category = (0, exports.getColumnCategory)(fieldName, typeInfo.data_type, typeInfo.semantic_type);
        return {
            id: fieldName,
            name: displayName,
            description: `${displayName} field`,
            field: fieldName,
            sortable,
            hideable: true,
            default_visible: entityMapping.defaultVisibleFields.includes(fieldName),
            data_type: typeInfo.data_type,
            semantic_type: typeInfo.semantic_type,
            context: typeInfo.context,
            default_order: defaultOrder,
            category,
        };
    });
    const relationshipColumns = [];
    if (finalRelations.size > 0) {
        for (const [relationName, relatedTypeName] of finalRelations) {
            const allRelatedFields = (0, utils_1.graphqlSchemaToFields)(schemaTypeMap, relatedTypeName, []);
            // Filter out problematic fields from related type
            const relatedType = schemaTypeMap[relatedTypeName];
            const relatedFields = allRelatedFields.filter((fieldName) => {
                const field = relatedType?.getFields()[fieldName];
                if (!field)
                    return true;
                const isArray = (0, exports.isArrayField)(field.type);
                if (isArray) {
                    return false;
                }
                // Apply entity-specific field filters to related fields as well
                if ((0, exports.shouldExcludeField)(fieldName, entityMapping.fieldFilters)) {
                    return false;
                }
                return true;
            });
            const limitedFields = relatedFields.slice(0, 10);
            limitedFields.forEach((fieldName) => {
                const fieldPath = `${relationName}.${fieldName}`;
                const displayName = `${(0, exports.formatFieldName)(relationName)} ${(0, exports.formatFieldName)(fieldName)}`;
                const relatedType = schemaTypeMap[relatedTypeName];
                const fieldDef = relatedType?.getFields()?.[fieldName];
                const typeInfo = fieldDef
                    ? (0, exports.getTypeInfoFromGraphQLType)(fieldDef.type, fieldName)
                    : {
                        data_type: "string",
                        semantic_type: "string",
                        context: "generic",
                    };
                const sortable = fieldPath.includes(".")
                    ? false
                    : ["name", "title", "email", "handle"].includes(fieldName);
                const isDefaultVisible = entityMapping.defaultVisibleFields.includes(fieldPath);
                // Get default order and category
                // If field is not in default visible fields, place it after country (850)
                const isDefaultField = entityMapping.defaultVisibleFields.includes(fieldPath);
                const defaultOrder = exports.DEFAULT_COLUMN_ORDERS[fieldPath] || (isDefaultField ? 700 : 850);
                const category = (0, exports.getColumnCategory)(fieldPath, typeInfo.data_type, typeInfo.semantic_type);
                relationshipColumns.push({
                    id: fieldPath,
                    name: displayName,
                    description: `${displayName} from related ${relatedTypeName}`,
                    field: fieldPath,
                    sortable,
                    hideable: true,
                    default_visible: isDefaultVisible,
                    data_type: typeInfo.data_type,
                    semantic_type: typeInfo.semantic_type,
                    context: typeInfo.context,
                    relationship: {
                        entity: relatedTypeName,
                        field: fieldName,
                    },
                    default_order: defaultOrder,
                    category,
                });
            });
        }
    }
    // Generate computed columns
    const computedColumns = [];
    if (entityMapping.computedColumns) {
        for (const [columnId, columnConfig] of Object.entries(entityMapping.computedColumns)) {
            // Get default order and category for computed columns
            // If field is not in default visible fields, place it after country (850)
            const isDefaultField = entityMapping.defaultVisibleFields.includes(columnId);
            const defaultOrder = exports.DEFAULT_COLUMN_ORDERS[columnId] || (isDefaultField ? 600 : 850);
            const category = (0, exports.getColumnCategory)(columnId, "string", "computed");
            computedColumns.push({
                id: columnId,
                name: columnConfig.name,
                description: `${columnConfig.name} (computed)`,
                field: columnId,
                sortable: false, // Computed columns can't be sorted server-side
                hideable: true,
                default_visible: entityMapping.defaultVisibleFields.includes(columnId),
                data_type: "string", // Computed columns typically output strings
                semantic_type: "computed",
                context: "display",
                computed: {
                    type: columnConfig.computation_type,
                    required_fields: columnConfig.required_fields,
                    optional_fields: columnConfig.optional_fields || [],
                },
                default_order: defaultOrder,
                category,
            });
        }
    }
    const allColumns = [
        ...directColumns,
        ...relationshipColumns,
        ...computedColumns,
    ];
    return allColumns;
};
exports.generateEntityColumns = generateEntityColumns;
//# sourceMappingURL=helpers.js.map
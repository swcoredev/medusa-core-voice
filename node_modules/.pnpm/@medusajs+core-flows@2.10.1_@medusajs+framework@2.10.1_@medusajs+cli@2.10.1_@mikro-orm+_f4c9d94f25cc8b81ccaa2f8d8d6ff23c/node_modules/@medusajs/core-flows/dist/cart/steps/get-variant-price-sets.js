"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariantPriceSetsStep = exports.getVariantPriceSetsStepId = void 0;
const utils_1 = require("@medusajs/framework/utils");
const workflows_sdk_1 = require("@medusajs/framework/workflows-sdk");
exports.getVariantPriceSetsStepId = "get-variant-price-sets";
async function fetchVariantPriceSets(query, variantIds) {
    return (await query.graph({
        entity: "variant",
        fields: ["id", "price_set.id"],
        filters: { id: variantIds },
    })).data;
}
/**
 * Validates that all variants have price sets and throws error for missing ones
 */
function validateVariantPriceSets(variantPriceSets) {
    const notFound = variantPriceSets
        .filter((v) => !v.price_set?.id)
        .map((v) => v.id);
    if (notFound.length) {
        throw new utils_1.MedusaError(utils_1.MedusaError.Types.INVALID_DATA, `Variants with IDs ${notFound.join(", ")} do not have a price`);
    }
}
/**
 * Unified function to process variants with context grouping optimization
 * TODO: to be discussed, support batch calculation from the pricing module. Currently
 * trying to mitigate the impact by grouping items by exact same context.
 */
async function processVariantPriceSets(pricingService, items) {
    const result = {};
    // Group items by their context to minimize API calls
    const contextGroups = groupItemsByContext(items);
    for (const [, groupItems] of contextGroups) {
        const priceSetIds = groupItems.map((item) => item.priceSetId);
        const context = groupItems[0].context; // All items in group have same context
        const calculatedPriceSets = await pricingService.calculatePrices({ id: priceSetIds }, { context: context });
        // Map calculated prices back to variants
        const priceSetMap = new Map(calculatedPriceSets.map((priceSet) => [priceSet.id, priceSet]));
        for (const item of groupItems) {
            const calculatedPriceSet = priceSetMap.get(item.priceSetId);
            if (calculatedPriceSet) {
                result[item.variantId] = calculatedPriceSet;
            }
        }
    }
    return result;
}
function createContextKey(context) {
    if (!context || Object.keys(context).length === 0) {
        return "no-context";
    }
    // Sort keys to ensure consistent grouping regardless of key order
    const sortedEntries = Object.entries(context)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([key, value]) => `${key}:${JSON.stringify(value)}`);
    return sortedEntries.join("|");
}
/**
 * Groups calculation items by their context. It results in less API calls to the pricing module
 * if we are able to group multiple item with the exact same context
 */
function groupItemsByContext(items) {
    const groups = new Map();
    for (const item of items) {
        const contextKey = createContextKey(item.context);
        const existingGroup = groups.get(contextKey);
        if (existingGroup) {
            existingGroup.push(item);
        }
        else {
            groups.set(contextKey, [item]);
        }
    }
    return groups;
}
/**
 * Converts shared context input to unified calculation items format
 */
function createCalculationItemsFromSharedContext(variantPriceSets, sharedContext) {
    return variantPriceSets
        .filter((v) => v.price_set?.id)
        .map((v) => ({
        variantId: v.id,
        priceSetId: v.price_set.id,
        context: sharedContext,
    }));
}
/**
 * Converts individual context input to unified calculation items format
 */
function createCalculationItemsFromBulkData(bulkData, variantToPriceSetId) {
    const calculationItems = [];
    for (const item of bulkData) {
        const priceSetId = variantToPriceSetId.get(item.variantId);
        if (priceSetId) {
            calculationItems.push({
                variantId: item.variantId,
                priceSetId,
                context: item.context,
            });
        }
    }
    return calculationItems;
}
/**
 * This step retrieves the calculated price sets of the specified variants.
 *
 * @example
 * To retrieve variant price sets with shared context:
 *
 * ```ts
 * const data = getVariantPriceSetsStep({
 *   variantIds: ["variant_123"],
 *   context: { currency_code: "usd" }
 * })
 * ```
 *
 * To retrieve variant price sets with individual contexts:
 *
 * ```ts
 * const data = getVariantPriceSetsStep({
 *   data: [
 *     { variantId: "variant_123", context: { currency_code: "usd" } },
 *     { variantId: "variant_456", context: { currency_code: "usd" } }, // Same context - will be batched
 *     { variantId: "variant_789", context: { currency_code: "eur" } }
 *   ]
 * })
 * ```
 */
exports.getVariantPriceSetsStep = (0, workflows_sdk_1.createStep)(exports.getVariantPriceSetsStepId, async (data, { container }) => {
    const pricingModuleService = container.resolve(utils_1.Modules.PRICING);
    const query = container.resolve(utils_1.ContainerRegistrationKeys.QUERY);
    let calculationItems;
    // Handle shared context variants (original input format)
    if ("variantIds" in data) {
        if (!data.variantIds.length) {
            return new workflows_sdk_1.StepResponse({});
        }
        const variantPriceSets = await fetchVariantPriceSets(query, data.variantIds);
        validateVariantPriceSets(variantPriceSets);
        calculationItems = createCalculationItemsFromSharedContext(variantPriceSets, data.context);
    }
    else {
        // Handle individual context variants (bulk input format)
        const bulkData = data.data;
        if (!bulkData.length) {
            return new workflows_sdk_1.StepResponse({});
        }
        const variantIds = bulkData.map((item) => item.variantId);
        const variantPriceSets = await fetchVariantPriceSets(query, variantIds);
        validateVariantPriceSets(variantPriceSets);
        // Map variant IDs to price set IDs
        const variantToPriceSetId = new Map();
        variantPriceSets.forEach((v) => {
            if (v.price_set?.id) {
                variantToPriceSetId.set(v.id, v.price_set.id);
            }
        });
        calculationItems = createCalculationItemsFromBulkData(bulkData, variantToPriceSetId);
    }
    // Use unified processing logic for both input types
    const result = await processVariantPriceSets(pricingModuleService, calculationItems);
    return new workflows_sdk_1.StepResponse(result);
});
//# sourceMappingURL=get-variant-price-sets.js.map